name: 'API CI/CD Pipeline (reusable)'

on:
  workflow_call:
    inputs:
      # Version configuration (for version job)
      major-version:
        description: 'Major version number'
        required: false
        default: '1'
        type: string
      minor-version:
        description: 'Minor version number'
        required: false
        default: '0'
        type: string
      
      # Docker configuration (for build job)
      dockerfile-path:
        description: 'Path to Dockerfile'
        required: false
        default: './Dockerfile'
        type: string
      docker-context:
        description: 'Docker build context'
        required: false
        default: '.'
        type: string
      docker-platforms:
        description: 'Target platforms for Docker build'
        required: false
        default: 'linux/amd64'
        type: string
      
      # Helm configuration (for build job)
      chart-path:
        description: 'Helm chart path: Local directory (e.g., "./chart") or external Helm repository URL (e.g., "https://charts.sf9.io")'
        required: false
        default: './chart'
        type: string
      chart-name:
        description: 'Your application name: This becomes your app name in Kubernetes. For external charts, this will be the name of the repackaged chart.'
        required: true
        type: string
      chart-version:
        description: 'Chart version: For external charts, specify which version to pull (e.g., "1.2.3", "latest"). For local charts, this is ignored as the generated semantic version is used.'
        required: false
        default: 'latest'
        type: string
      source-chart-name:
        description: 'Source chart name: For external charts, this is the name of the chart to pull from the repository (e.g., "s9genericchart"). For local charts, this is ignored.'
        required: false
        default: 's9genericchart'
        type: string
      
      # Registry configuration (for build job)
      container-registry:
        description: 'Container registry (docker.io, ghcr.io, etc.)'
        required: false
        default: 'ghcr.io'
        type: string
      image-name:
        description: 'Docker image name (will use repository name if not provided)'
        required: false
        type: string
      
      # Helm image configuration (for your specific template structure)
      helm-image-repo:
        description: 'Helm image.repo value (will use container-registry/image-name if not provided)'
        required: false
        type: string
      helm-app-name:
        description: 'Helm app.name value (will use chart-name if not provided)'
        required: false
        type: string
      
      # Development deployment configuration (for deploy-development job)
      deploy-to-development:
        description: 'Deploy to development environment'
        required: false
        default: false
        type: boolean
      development-namespace:
        description: 'Kubernetes namespace for development'
        required: false
        default: 'development'
        type: string
      development-helm-set-values:
        description: 'Development Helm set values (comma-separated: key1=value1,key2=value2)'
        required: false
        type: string
      
      # Staging deployment configuration (for deploy-staging job)
      deploy-to-staging:
        description: 'Deploy to staging environment'
        required: false
        default: false
        type: boolean
      staging-namespace:
        description: 'Kubernetes namespace for staging'
        required: false
        default: 'staging'
        type: string
      staging-helm-set-values:
        description: 'Staging Helm set values (comma-separated: key1=value1,key2=value2)'
        required: false
        type: string
      
      # Production deployment configuration (for deploy-production job)
      deploy-to-production:
        description: 'Deploy to production environment'
        required: false
        default: false
        type: boolean
      production-namespace:
        description: 'Kubernetes namespace for production'
        required: false
        default: 'production'
        type: string
      production-helm-set-values:
        description: 'Production Helm set values (comma-separated: key1=value1,key2=value2)'
        required: false
        type: string

      # Dynamic deployment value inputs (generic, not prefixed with environment)
      environment:
        description: 'Value for environment Helm set (e.g., Development, Staging)'
        required: false
        type: string
      app-name:
        description: 'Application name for app.name Helm value (overrides helm-app-name)'
        required: false
        type: string
      ingress-host:
        description: 'Primary ingress host (maps to ingress.hosts[0].host)'
        required: false
        type: string
      service-target-port:
        description: 'Service targetPort (maps to service.targetPort)'
        required: false
        type: string
      ingress-hosts:
        description: 'Comma-separated list of ingress hosts (maps to ingress.hosts[i].host)'
        required: false
        type: string
      ingress-paths:
        description: 'Comma-separated list of ingress paths (maps to ingress.paths[i])'
        required: false
        type: string
      ingress-tls-secrets:
        description: 'Comma or newline separated list of TLS secrets matching ingress-hosts by index; falls back to ingress-tls-secret if absent'
        required: false
        type: string

    secrets:
      # Container registry secrets
      registry-username:
        description: 'Container registry username'
        required: false
      registry-password:
        description: 'Container registry password/token'
        required: false
      
      # Kubernetes secrets
      kubeconfig:
        description: 'Base64 encoded kubeconfig'
        required: false
      
      # GitHub token for tagging
      github-token:
        description: 'GitHub token for tagging'
        required: false
      
      # Secret deployment values (ordered by deployment stages)
      development-helm-set-secret-values:
        description: 'Development Helm set secret values (comma-separated: key1=value1,key2=value2)'
        required: false
      staging-helm-set-secret-values:
        description: 'Staging Helm set secret values (comma-separated: key1=value1,key2=value2)'
        required: false
      production-helm-set-secret-values:
        description: 'Production Helm set secret values (comma-separated: key1=value1,key2=value2)'
        required: false

    outputs:
      version:
        description: 'Generated semantic version'
        value: ${{ jobs.version.outputs.version }}
      docker-image:
        description: 'Built Docker image with tag'
        value: ${{ jobs.build.outputs.docker-image }}
      helm-chart:
        description: 'Published Helm chart URL'
        value: ${{ jobs.build.outputs.helm-chart }}

env:
  # Set default registry and image name
  CONTAINER_REGISTRY: ${{ inputs.container-registry }}
  IMAGE_NAME: ${{ inputs.image-name || github.repository }}

jobs:
  version:
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.semver.outputs.version }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Determine semantic version
        id: semver
        uses: simplify9/.github/.github/actions/determine-semver@main
        with:
          major: ${{ inputs.major-version }}
          minor: ${{ inputs.minor-version }}
 
      - name: Tag new version on GitHub origin
        uses: simplify9/.github/.github/actions/tag-github-origin@main
        with:
          github-token: ${{ secrets.github-token || secrets.GITHUB_TOKEN }}
          repository: ${{ github.repository }}
          tag: ${{ steps.semver.outputs.version }}
          sha: ${{ github.sha }}

  build:
    runs-on: ubuntu-latest
    needs: version
    outputs:
      docker-image: ${{ steps.docker.outputs.image-tags }}
      helm-chart: ${{ steps.helm.outputs.chart-url }}
      chart-source: ${{ steps.detect-chart.outputs.chart-source }}
      chart-path-for-deployment: ${{ steps.detect-chart.outputs.chart-path-for-deployment }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Detect chart source and configure deployment
        id: detect-chart
        shell: bash
        run: |
          CHART_PATH="${{ inputs.chart-path }}"
          
          # Check if chart-path starts with http:// or https://
          if [[ "$CHART_PATH" =~ ^https?:// ]]; then
            echo "chart-source=external" >> "$GITHUB_OUTPUT"
            echo "chart-path-for-deployment=./${{ inputs.chart-name }}" >> "$GITHUB_OUTPUT"
            echo "External chart detected: $CHART_PATH"
            echo "Will pull, repackage with app name, and deploy as local chart"
          else
            echo "chart-source=local" >> "$GITHUB_OUTPUT"
            echo "chart-path-for-deployment=$CHART_PATH" >> "$GITHUB_OUTPUT"
            echo "Local chart detected: $CHART_PATH"
          fi

      - name: Build and push Docker image
        id: docker
        uses: simplify9/.github/.github/actions/docker-build-push@main
        with:
          registry: ${{ env.CONTAINER_REGISTRY }}
          image-name: ${{ env.IMAGE_NAME }}
          version: ${{ needs.version.outputs.version }}
          username: ${{ secrets.registry-username || github.actor }}
          password: ${{ secrets.registry-password || secrets.GITHUB_TOKEN }}
          dockerfile: ${{ inputs.dockerfile-path }}
          context: ${{ inputs.docker-context }}
          platforms: ${{ inputs.docker-platforms }}

      - name: Pull and repackage external chart
        if: steps.detect-chart.outputs.chart-source == 'external'
        shell: bash
        run: |
          echo "Setting up Helm..."
          curl https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3 | bash
          
          echo "Processing external chart..."
          CHART_URL="${{ inputs.chart-path }}"
          SOURCE_CHART_NAME="${{ inputs.source-chart-name }}"
          TARGET_CHART_NAME="${{ inputs.chart-name }}"
          CHART_VERSION="${{ inputs.chart-version }}"
          
          echo "Repository URL: $CHART_URL"
          echo "Source Chart Name: $SOURCE_CHART_NAME (chart to pull from repo)"
          echo "Target Chart Name: $TARGET_CHART_NAME (your app name)"
          echo "Chart Version: $CHART_VERSION"
          
          # Generate a unique repo name based on URL
          REPO_NAME=$(echo "$CHART_URL" | sed 's|https\?://||' | sed 's|[^a-zA-Z0-9]|-|g' | sed 's/--*/-/g' | sed 's/-$//')
          echo "Generated repo name: $REPO_NAME"
          
          # Add the external repository
          echo "Adding Helm repository..."
          helm repo add "$REPO_NAME" "$CHART_URL"
          helm repo update
          
          # List available charts in the repo for debugging
          echo "Available charts in repository:"
          helm search repo "$REPO_NAME" || echo "Could not list charts (this is normal for some repos)"
          
          # Pull the specific chart using the source chart name
          echo "Pulling chart: $REPO_NAME/$SOURCE_CHART_NAME version $CHART_VERSION"
          if ! helm pull "$REPO_NAME/$SOURCE_CHART_NAME" --version "$CHART_VERSION" --untar; then
            echo "Failed to pull chart with version. Trying without version specification..."
            if ! helm pull "$REPO_NAME/$SOURCE_CHART_NAME" --untar; then
              echo "Failed to pull chart. Available charts:"
              helm search repo "$REPO_NAME" || true
              echo "ERROR: Could not pull chart '$SOURCE_CHART_NAME' from repository '$CHART_URL'"
              echo "Please verify:"
              echo "  - Repository URL is correct: $CHART_URL"
              echo "  - Source chart name exists: $SOURCE_CHART_NAME"
              echo "  - Chart version is available: $CHART_VERSION"
              exit 1
            fi
          fi
          
          # The chart is extracted with its original name, so we need to rename the directory
          EXTRACTED_DIR="$SOURCE_CHART_NAME"
          if [ ! -d "$EXTRACTED_DIR" ]; then
            echo "ERROR: Chart directory '$EXTRACTED_DIR' not found after extraction"
            echo "Available directories:"
            ls -la
            exit 1
          fi
          
          # Rename the directory to match our target chart name
          if [ "$SOURCE_CHART_NAME" != "$TARGET_CHART_NAME" ]; then
            echo "Renaming chart directory from '$SOURCE_CHART_NAME' to '$TARGET_CHART_NAME'"
            mv "$SOURCE_CHART_NAME" "$TARGET_CHART_NAME"
          fi
          
          echo "Chart directory contents:"
          ls -la "$TARGET_CHART_NAME"/
          
          echo "Original Chart.yaml:"
          cat "$TARGET_CHART_NAME/Chart.yaml"
          
          echo "Customizing chart metadata..."
          # Update Chart.yaml with our target app name and version
          sed -i.bak "s/^name:.*/name: $TARGET_CHART_NAME/" "$TARGET_CHART_NAME/Chart.yaml"
          sed -i.bak "s/^version:.*/version: ${{ needs.version.outputs.version }}/" "$TARGET_CHART_NAME/Chart.yaml"  
          sed -i.bak "s/^appVersion:.*/appVersion: ${{ needs.version.outputs.version }}/" "$TARGET_CHART_NAME/Chart.yaml"
          
          echo "Updated Chart.yaml:"
          cat "$TARGET_CHART_NAME/Chart.yaml"
          
          echo "Chart repackaging completed successfully"
          echo "Source: $SOURCE_CHART_NAME from $CHART_URL"
          echo "Target: $TARGET_CHART_NAME (your app name)"

      - name: Upload chart artifact (unified for both local and external)
        uses: actions/upload-artifact@v4
        with:
          name: helm-chart-${{ inputs.chart-name }}
          path: ${{ steps.detect-chart.outputs.chart-source == 'external' && inputs.chart-name || format('{0}-artifact', inputs.chart-name) }}/
          retention-days: 1

      - name: Package and push Helm chart (local charts only)
        id: helm
        if: steps.detect-chart.outputs.chart-source == 'local'
        uses: simplify9/.github/.github/actions/helm-package-push@main
        with:
          chart-name: ${{ inputs.chart-name }}
          chart-path: ${{ inputs.chart-path }}
          version: ${{ needs.version.outputs.version }}
          registry: ${{ env.CONTAINER_REGISTRY }}
          repository: ${{ github.repository_owner }}/charts
          username: ${{ secrets.registry-username || github.actor }}
          password: ${{ secrets.registry-password || secrets.GITHUB_TOKEN }}
          image-repository: ${{ env.CONTAINER_REGISTRY }}/${{ github.repository }}
          image-tag: ${{ needs.version.outputs.version }}
          update-image-values: 'true'

      - name: Create artifact for local chart
        if: steps.detect-chart.outputs.chart-source == 'local'
        shell: bash
        run: |
          echo "Creating artifact copy of local chart for unified deployment..."
          cp -r ${{ inputs.chart-path }} ${{ inputs.chart-name }}-artifact
          
          # Update the chart with version and image info for artifact deployment
          sed -i.bak "s/^version:.*/version: ${{ needs.version.outputs.version }}/" "${{ inputs.chart-name }}-artifact/Chart.yaml"
          sed -i.bak "s/^appVersion:.*/appVersion: ${{ needs.version.outputs.version }}/" "${{ inputs.chart-name }}-artifact/Chart.yaml"
          
          echo "Local chart prepared for artifact deployment"

  deploy-development:
    runs-on: ubuntu-latest
    needs: [version, build]
    if: inputs.deploy-to-development
    environment: development
    steps:
      - name: Download chart artifact
        uses: actions/download-artifact@v4
        with:
          name: helm-chart-${{ inputs.chart-name }}
          path: ${{ inputs.chart-name }}

      - name: Generate dynamic ingress values
        id: ingress
        shell: bash
        run: |
          HOSTS_INPUT="${{ inputs.ingress-hosts }}"
          PATHS_INPUT="${{ inputs.ingress-paths }}"
          TLS_ARRAY_INPUT="${{ inputs.ingress-tls-secrets }}"

          # Supports both comma-separated and multiline YAML block scalar inputs.
          # Example multiline usage:
          # ingress-hosts: |
          #   host1.example.com
          #   host2.example.com
          # ingress-paths: |
          #   /api
          #   /docs
          #   /metrics

          OUTPUT=""

          if [ -n "$HOSTS_INPUT" ]; then
            HOSTS_CLEAN=$(echo "$HOSTS_INPUT" | sed 's/\r//g' | tr ',' '\n')
            # Prepare TLS secrets list if provided
            if [ -n "$TLS_ARRAY_INPUT" ]; then
              TLS_CLEAN=$(echo "$TLS_ARRAY_INPUT" | sed 's/\r//g' | tr ',' '\n')
              mapfile -t TLS_LIST < <(echo "$TLS_CLEAN" | grep -v '^[[:space:]]*$') || true
            fi
            INDEX=0
            while IFS= read -r line; do
              host=$(echo "$line" | xargs)
              [ -z "$host" ] && continue
              OUTPUT+="ingress.hosts[$INDEX].host=$host\n"
              host_tls=""
              if [ -n "$TLS_ARRAY_INPUT" ] && [ $INDEX -lt ${#TLS_LIST[@]} ]; then
                host_tls=$(echo "${TLS_LIST[$INDEX]}" | xargs)
              fi
              if [ -n "$host_tls" ]; then
                OUTPUT+="ingress.hosts[$INDEX].tlsSecret=$host_tls\n"
              fi
              INDEX=$((INDEX+1))
            done <<< "$HOSTS_CLEAN"
          fi

          if [ -n "$PATHS_INPUT" ]; then
            PATHS_CLEAN=$(echo "$PATHS_INPUT" | sed 's/\r//g' | tr ',' '\n')
            PINDEX=0
            while IFS= read -r line; do
              path=$(echo "$line" | xargs)
              [ -z "$path" ] && continue
              OUTPUT+="ingress.paths[$PINDEX]=$path\n"
              PINDEX=$((PINDEX+1))
            done <<< "$PATHS_CLEAN"
          fi

          {
            echo "ingress-values<<EOF"
            echo -e "$OUTPUT"
            echo "EOF"
          } >> "$GITHUB_OUTPUT"

      - name: Deploy to Development (via local composite action)
        uses: simplify9/.github/.github/actions/helm-generic@fix
        with:
          # Required basics
          app_name: ${{ inputs.app-name || inputs.helm-app-name || inputs.chart-name }}
          namespace: ${{ inputs.development-namespace }}

          # Use the downloaded chart directory/package directly
          chart: ${{ inputs.chart-name }}
          chart_repo: "https://charts.sf9.io"

          # Helm timing/flags
          helm_timeout: '5m'
          extra_args: "--wait"

          # Translate your previous comma-joined --set into line-based entries
          extra_set_values: |
            image.repo=${{ inputs.helm-image-repo || format('{0}/{1}', env.CONTAINER_REGISTRY, env.IMAGE_NAME) }}
            app.name=${{ inputs.app-name || inputs.helm-app-name || inputs.chart-name }}
            app.version=${{ needs.version.outputs.version }}
            image.overrideName=${{ inputs.helm-app-name || inputs.chart-name }}
            image.overrideVersion=${{ needs.version.outputs.version }}
            environment=${{ inputs.environment }}
            service.targetPort=${{ inputs.service-target-port }}
            ${{ steps.ingress.outputs.ingress-values }}
            image.pullSecret=sf9cr
            ingress.annotations.cert-manager\.io/cluster-issuer=letsencrypt-nginx
            ingress.annotations.nginx\.ingress\.kubernetes\.io/proxy-body-size=50m
              ${{ inputs.development-helm-set-values }}
              
          # Kubeconfig (raw YAML or base64; your secret works for both)
          kubeconfig_data: ${{ secrets.kubeconfig }}

  deploy-staging:
    runs-on: ubuntu-latest
    needs: [version, build]
    if: inputs.deploy-to-staging && github.ref_name == 'staging'
    environment: staging
    steps:
      - name: Download chart artifact
        uses: actions/download-artifact@v4
        with:
          name: helm-chart-${{ inputs.chart-name }}
          path: ${{ inputs.chart-name }}

      - name: Deploy to Staging (Unified Artifact-Based)
        uses: simplify9/.github/.github/actions/helm-deploy-s9generic@main
        env:
          SECRET_VALUES: ${{ secrets.staging-helm-set-secret-values }}
        with:
          chart-name: ${{ inputs.chart-name }}
          chart-version: ${{ needs.version.outputs.version }}
          chart-path: ${{ inputs.chart-name }}
          kubeconfig: ${{ secrets.kubeconfig }}
          release-name: ${{ inputs.chart-name }}-staging
          namespace: ${{ inputs.staging-namespace }}
          set-values: >-
            image.repo=${{ inputs.helm-image-repo || format('{0}/{1}', env.CONTAINER_REGISTRY, env.IMAGE_NAME) }},
            app.name=${{ inputs.helm-app-name || inputs.chart-name }},
            app.version=${{ needs.version.outputs.version }},
            image.overrideName=${{ inputs.helm-app-name || inputs.chart-name }},
            image.overrideVersion=${{ needs.version.outputs.version }}${{ inputs.staging-helm-set-values && format(',{0}', inputs.staging-helm-set-values) || '' }}
          timeout: '5m'

  deploy-production:
    runs-on: ubuntu-latest
    needs: [version, build]
    if: inputs.deploy-to-production && (github.ref_name == 'main' || github.ref_name == 'master')
    environment: production
    steps:
      - name: Download chart artifact
        uses: actions/download-artifact@v4
        with:
          name: helm-chart-${{ inputs.chart-name }}
          path: ${{ inputs.chart-name }}

      - name: Deploy to Production (Unified Artifact-Based)
        uses: simplify9/.github/.github/actions/helm-deploy-s9generic@main
        env:
          SECRET_VALUES: ${{ secrets.production-helm-set-secret-values }}
        with:
          chart-name: ${{ inputs.chart-name }}
          chart-version: ${{ needs.version.outputs.version }}
          chart-path: ${{ inputs.chart-name }}
          kubeconfig: ${{ secrets.kubeconfig }}
          release-name: ${{ inputs.chart-name }}-prod
          namespace: ${{ inputs.production-namespace }}
          set-values: >-
            image.repo=${{ inputs.helm-image-repo || format('{0}/{1}', env.CONTAINER_REGISTRY, env.IMAGE_NAME) }},
            app.name=${{ inputs.helm-app-name || inputs.chart-name }},
            app.version=${{ needs.version.outputs.version }},
            image.overrideName=${{ inputs.helm-app-name || inputs.chart-name }},
            image.overrideVersion=${{ needs.version.outputs.version }}${{ inputs.production-helm-set-values && format(',{0}', inputs.production-helm-set-values) || '' }}
          timeout: '5m'