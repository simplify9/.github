name: 'Helm Deploy to Kubernetes'
description: 'Deploy Helm chart from OCI registry to Kubernetes cluster'
author: 'Simplify9'

inputs:
  chart-name:
    description: 'Name of the Helm chart'
    required: true
  chart-version:
    description: 'Version of the Helm chart to deploy'
    required: true
  chart-path:
    description: 'Local path to chart directory (for artifact-based deployment). If provided, will deploy from local chart instead of OCI registry.'
    required: false
  registry:
    description: 'OCI registry URL where the chart is stored (ignored if chart-path is provided)'
    required: false
    default: 'docker.io'
  repository:
    description: 'Repository path in the registry (ignored if chart-path is provided)'
    required: false
  registry-username:
    description: 'Registry username for authentication (ignored if chart-path is provided)'
    required: false
  registry-password:
    description: 'Registry password or token for authentication (ignored if chart-path is provided)'
    required: false
  kubeconfig:
    description: 'Base64 encoded kubeconfig for cluster access'
    required: true
  release-name:
    description: 'Helm release name'
    required: false
    default: 'app'
  namespace:
    description: 'Kubernetes namespace to deploy to'
    required: false
    default: 'default'
  image-repository:
    description: 'Docker image repository (for --set image.repository)'
    required: false
  image-tag:
    description: 'Docker image tag (for --set image.tag)'
    required: false
  values-file:
    description: 'Path to values file (relative to chart)'
    required: false
  values:
    description: 'Additional Helm values as YAML string'
    required: false
  set-values:
    description: 'Additional --set values (comma-separated: key1=value1,key2=value2)'
    required: false
  set-string-values:
    description: 'Additional --set-string values (comma-separated: key1=value1,key2=value2)'
    required: false
  timeout:
    description: 'Helm deployment timeout'
    required: false
    default: '10m'
  wait:
    description: 'Wait for deployment to complete'
    required: false
    default: 'true'
  create-namespace:
    description: 'Create namespace if it does not exist'
    required: false
    default: 'true'
  helm-version:
    description: 'Helm version to install'
    required: false
    default: 'latest'
  kubectl-version:
    description: 'kubectl version to install'
    required: false
    default: 'latest'

outputs:
  release-status:
    description: 'Status of the Helm release'
    value: ${{ steps.deploy.outputs.status }}
  chart-url:
    description: 'Full OCI URL of the deployed chart'
    value: ${{ steps.deploy.outputs.chart-url }}
  namespace:
    description: 'Namespace where the release was deployed'
    value: ${{ inputs.namespace }}
  deployed-image:
    description: 'Container image reference (best-effort repo/name:tag) actually applied'
    value: ${{ steps.deploy.outputs.deployed-image }}

runs:
  using: 'composite'
  steps:
    - name: Validate inputs
      shell: bash
      run: |
        if [ -z "${{ inputs.chart-path }}" ]; then
          # OCI registry deployment - validate required inputs
          if [ -z "${{ inputs.repository }}" ]; then
            echo "Error: 'repository' is required when deploying from OCI registry (chart-path not provided)"
            exit 1
          fi
          if [ -z "${{ inputs.registry-username }}" ]; then
            echo "Error: 'registry-username' is required when deploying from OCI registry (chart-path not provided)"
            exit 1
          fi
          if [ -z "${{ inputs.registry-password }}" ]; then
            echo "Error: 'registry-password' is required when deploying from OCI registry (chart-path not provided)"
            exit 1
          fi
          echo "Validation passed: OCI registry deployment"
        else
          echo "Validation passed: Local chart deployment from ${{ inputs.chart-path }}"
        fi

    - name: Set up Helm
      uses: azure/setup-helm@v4
      with:
        version: ${{ inputs.helm-version }}

    - name: Set up kubectl
      uses: azure/setup-kubectl@v4
      with:
        version: ${{ inputs.kubectl-version }}

    - name: Configure Kubernetes context
      shell: bash
      run: |
        echo "Configuring Kubernetes context..."
        mkdir -p ~/.kube
        echo "${{ inputs.kubeconfig }}" | base64 -d > ~/.kube/config
        chmod 600 ~/.kube/config
        
        echo "Current context:"
        kubectl config current-context
        
        echo "Cluster info:"
        kubectl cluster-info

    - name: Create namespace
      if: inputs.create-namespace == 'true'
      shell: bash
      run: |
        echo "Creating namespace: ${{ inputs.namespace }}"
        kubectl create namespace ${{ inputs.namespace }} --dry-run=client -o yaml | kubectl apply -f -

    - name: Configure Helm registry authentication
      if: inputs.chart-path == ''
      shell: bash
      run: |
        echo "Configuring Helm registry authentication for ${{ inputs.registry }}"
        if [ "${{ inputs.registry }}" != "docker.io" ]; then
          helm registry login ${{ inputs.registry }} -u ${{ inputs.registry-username }} -p ${{ inputs.registry-password }}
        else
          helm registry login -u ${{ inputs.registry-username }} -p ${{ inputs.registry-password }}
        fi

    - name: Prepare values file
      if: inputs.values != ''
      shell: bash
      run: |
        echo "Creating temporary values file..."
        cat > /tmp/custom-values.yaml << 'EOF'
        ${{ inputs.values }}
        EOF
        echo "Custom values:"
        cat /tmp/custom-values.yaml

    - name: Deploy Helm chart
      id: deploy
      shell: bash
      run: |
        # Determine chart source and construct deployment command
        if [ -n "${{ inputs.chart-path }}" ]; then
          # Deploy from local chart path (artifact-based deployment)
          CHART_SOURCE="${{ inputs.chart-path }}"
          echo "Deploying from local chart: ${CHART_SOURCE}"
          
          # Verify chart exists
          if [ ! -d "${CHART_SOURCE}" ]; then
            echo "Error: Chart directory not found: ${CHART_SOURCE}"
            ls -la .
            exit 1
          fi
          
          if [ ! -f "${CHART_SOURCE}/Chart.yaml" ]; then
            echo "Error: Chart.yaml not found in: ${CHART_SOURCE}"
            ls -la "${CHART_SOURCE}"
            exit 1
          fi
          
          echo "Chart directory contents:"
          ls -la "${CHART_SOURCE}"
          echo "Chart.yaml:"
          cat "${CHART_SOURCE}/Chart.yaml"
          
          echo "chart-url=local:${CHART_SOURCE}" >> $GITHUB_OUTPUT
        else
          # Deploy from OCI registry (original behavior)
          if [ "${{ inputs.registry }}" != "docker.io" ]; then
            CHART_SOURCE="oci://${{ inputs.registry }}/${{ inputs.repository }}/${{ inputs.chart-name }}:${{ inputs.chart-version }}"
          else
            CHART_SOURCE="oci://${{ inputs.repository }}/${{ inputs.chart-name }}:${{ inputs.chart-version }}"
          fi
          
          echo "Deploying from OCI registry: ${CHART_SOURCE}"
          echo "chart-url=${CHART_SOURCE}" >> $GITHUB_OUTPUT
        fi
        
        echo "Deploying Helm chart..."
        echo "Chart Source: ${CHART_SOURCE}"
        echo "Release name: ${{ inputs.release-name }}"
        echo "Namespace: ${{ inputs.namespace }}"
        
        # Debug: Show what we received
        echo "=== ACTION DEBUG: Received Values ==="
        echo "set-values input: '${{ inputs.set-values }}'"
        echo "set-string-values input: '${{ inputs.set-string-values }}'"
        echo "SECRET_VALUES env: '$SECRET_VALUES'"
        echo "SECRET_VALUES length: ${#SECRET_VALUES}"
        if [ -n "$SECRET_VALUES" ]; then
          echo "SECRET_VALUES hex dump:"
          echo "$SECRET_VALUES" | hexdump -C | head -5
          echo "Contains semicolons: $(echo "$SECRET_VALUES" | grep -c ';' || echo '0')"
          echo "Contains equals: $(echo "$SECRET_VALUES" | grep -c '=' || echo '0')"
          echo "Contains spaces: $(echo "$SECRET_VALUES" | grep -c ' ' || echo '0')"
        fi
        echo "======================================"
        
        # Build helm command as array to properly handle arguments with spaces and special characters
        HELM_ARGS=("helm" "upgrade" "--install" "${{ inputs.release-name }}" "${CHART_SOURCE}" "--namespace" "${{ inputs.namespace }}")
        
        # Add timeout and wait options
        if [ "${{ inputs.wait }}" == "true" ]; then
          HELM_ARGS+=("--wait")
        fi
        HELM_ARGS+=("--timeout" "${{ inputs.timeout }}")
        
        # Add image repository and tag if provided
        if [ -n "${{ inputs.image-repository }}" ]; then
          HELM_ARGS+=("--set" "image.repository=${{ inputs.image-repository }}")
        fi
        if [ -n "${{ inputs.image-tag }}" ]; then
          HELM_ARGS+=("--set" "image.tag=${{ inputs.image-tag }}")
        fi
        
        # Add values file if provided
        if [ -n "${{ inputs.values-file }}" ]; then
          HELM_ARGS+=("--values" "${{ inputs.values-file }}")
        fi
        if [ "${{ inputs.values }}" != "" ]; then
          HELM_ARGS+=("--values" "/tmp/custom-values.yaml")
        fi
        
        # Add custom set values (regular values)
        if [ -n "${{ inputs.set-values }}" ]; then
          IFS=',' read -ra VALUES <<< "${{ inputs.set-values }}"
          for value in "${VALUES[@]}"; do
            # Trim leading/trailing whitespace
            trimmed="$(echo "$value" | xargs)"
            if [ -n "$trimmed" ]; then
              HELM_ARGS+=("--set" "$trimmed")
            fi
          done
        fi
        
        # Add custom set-string values (secret values)
        # First try the environment variable (preferred), then fall back to input parameter
        secret_values=""
        if [ -n "$SECRET_VALUES" ]; then
          secret_values="$SECRET_VALUES"
          echo "Using secret values from environment variable"
        elif [ -n "${{ inputs.set-string-values }}" ]; then
          secret_values="${{ inputs.set-string-values }}"
          echo "Using secret values from input parameter"
        fi
        
        if [ -n "$secret_values" ]; then
          echo "Processing secret values..."
          echo "=== SECRET PROCESSING DEBUG ==="
          echo "secret_values variable: '$secret_values'"
          echo "secret_values length: ${#secret_values}"
          echo "============================="
          
          # Only process if we have actual content (not just whitespace)
          if [ -n "$(echo "$secret_values" | tr -d '[:space:]')" ]; then
            while [[ "$secret_values" == *","* ]]; do
              value="${secret_values%%,*}"
              if [ -n "$value" ]; then
                echo "Adding --set-string: $value"
                HELM_ARGS+=("--set-string" "$value")
              fi
              secret_values="${secret_values#*,}"
            done
            # Handle the last value (or only value if no commas)
            if [ -n "$secret_values" ]; then
              echo "Adding --set-string: $secret_values"
              HELM_ARGS+=("--set-string" "$secret_values")
            fi
          else
            echo "No secret values to process"
          fi
        else
          echo "No secret values provided"
        fi
        
        echo "Executing: ${HELM_ARGS[*]}"

        # Extra debug & output: attempt to reconstruct image reference from inputs or provided set-values
        DEPLOY_IMAGE=""
        if [ -n "${{ inputs.image-repository }}" ] && [ -n "${{ inputs.image-tag }}" ]; then
          DEPLOY_IMAGE="${{ inputs.image-repository }}:${{ inputs.image-tag }}"
          echo "Resolved image from explicit inputs: $DEPLOY_IMAGE"
        else
          RECON_SET_VALUES="${{ inputs.set-values }}"
          PARSED=$(echo "$RECON_SET_VALUES" | tr ',' '\n' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
          get_val() { echo "$PARSED" | grep -E "^$1=" | head -1 | cut -d'=' -f2-; }
          IMG_REPO=$(get_val "image.repo")
            IMG_OVERRIDE_NAME=$(get_val "image.overrideName")
          IMG_OVERRIDE_VERSION=$(get_val "image.overrideVersion")
          APP_NAME_VAL=$(get_val "app.name")
          APP_VERSION_VAL=$(get_val "app.version")
          [ -z "$IMG_OVERRIDE_NAME" ] && IMG_OVERRIDE_NAME="$APP_NAME_VAL"
          [ -z "$IMG_OVERRIDE_VERSION" ] && IMG_OVERRIDE_VERSION="$APP_VERSION_VAL"
          if [ -n "$IMG_REPO" ] && [ -n "$IMG_OVERRIDE_VERSION" ]; then
            DEPLOY_IMAGE="${IMG_REPO}/${IMG_OVERRIDE_NAME}:${IMG_OVERRIDE_VERSION}"
            echo "Resolved image (best-effort from set-values): ${DEPLOY_IMAGE}" 
          else
            echo "Could not fully resolve image reference (missing repo or version in set-values)." 
          fi
        fi

        if [ -n "$DEPLOY_IMAGE" ]; then
          echo "deployed-image=$DEPLOY_IMAGE" >> $GITHUB_OUTPUT
        fi

        echo "\nFull Helm command (args on separate lines for readability):"
        for i in "${!HELM_ARGS[@]}"; do
          printf '  %q\n' "${HELM_ARGS[$i]}"
        done
        "${HELM_ARGS[@]}"
        
        echo "status=deployed" >> $GITHUB_OUTPUT

    - name: Verify deployment
      shell: bash
      run: |
        echo "Verifying deployment..."
        
        echo "Helm release status:"
        helm status ${{ inputs.release-name }} --namespace ${{ inputs.namespace }}
        
        echo "Checking pods in namespace ${{ inputs.namespace }}:"
        kubectl get pods -n ${{ inputs.namespace }} -l app.kubernetes.io/instance=${{ inputs.release-name }}
        
        echo "Checking services:"
        kubectl get services -n ${{ inputs.namespace }} -l app.kubernetes.io/instance=${{ inputs.release-name }}
        
        echo "Deployment verification completed!"

    - name: Output deployment information
      shell: bash
      run: |
        echo "### 🚀 Deployment Summary" >> $GITHUB_STEP_SUMMARY
        echo "- **Release:** ${{ inputs.release-name }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Namespace:** ${{ inputs.namespace }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Chart:** ${{ inputs.chart-name }}:${{ inputs.chart-version }}" >> $GITHUB_STEP_SUMMARY
        
        if [ -n "${{ inputs.chart-path }}" ]; then
          echo "- **Source:** Local chart artifact (${{ inputs.chart-path }})" >> $GITHUB_STEP_SUMMARY
        else
          echo "- **Registry:** ${{ inputs.registry }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Repository:** ${{ inputs.repository }}" >> $GITHUB_STEP_SUMMARY
        fi
        
        if [ -n "${{ steps.deploy.outputs.deployed-image }}" ]; then
          echo "- **Image:** ${{ steps.deploy.outputs.deployed-image }}" >> $GITHUB_STEP_SUMMARY
        fi
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "**Management Commands:**" >> $GITHUB_STEP_SUMMARY
        echo '```bash' >> $GITHUB_STEP_SUMMARY
        echo "# Check status" >> $GITHUB_STEP_SUMMARY
        echo "helm status ${{ inputs.release-name }} -n ${{ inputs.namespace }}" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "# View pods" >> $GITHUB_STEP_SUMMARY
        echo "kubectl get pods -n ${{ inputs.namespace }} -l app.kubernetes.io/instance=${{ inputs.release-name }}" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "# Rollback if needed" >> $GITHUB_STEP_SUMMARY
        echo "helm rollback ${{ inputs.release-name }} -n ${{ inputs.namespace }}" >> $GITHUB_STEP_SUMMARY
        echo '```' >> $GITHUB_STEP_SUMMARY